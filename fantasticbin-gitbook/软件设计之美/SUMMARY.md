# SUMMARY

* [简介](./README.md)
* [开篇词 | 软件设计，应对需求规模的“算法”](./docs/240176.md)
* [01 | 软件设计到底是什么？](./docs/240177.md)
* [02 | 分离关注点：软件设计至关重要的第一步](./docs/240749.md)
* [03 | 可测试性： 一个影响软件设计的重要因素](./docs/241094.md)
* [04 | 三步走：如何了解一个软件的设计？](./docs/241114.md)
* [05 | Spring DI容器：如何分析一个软件的模型？](./docs/241123.md)
* [06 | Ruby on Rails：如何分析一个软件的接口？](./docs/241180.md)
* [07 | Kafka：如何分析一个软件的实现？](./docs/242501.md)
* [08 | 语言的模型：如何打破单一语言局限，让设计更好地落地？](./docs/245868.md)
* [09 | 语言的接口：语法和程序库，软件设计的发力点](./docs/245878.md)
* [10 | 语言的实现：运行时，软件设计的地基](./docs/245888.md)
* [11 | DSL：你也可以设计一门自己的语言](./docs/248638.md)
* [加餐 | 再八卦几门语言！](./docs/249596.md)
* [12 | 编程范式：明明写的是Java，为什么被人说成了C代码？](./docs/248650.md)
* [13 | 结构化编程：为什么做设计时仅有结构化编程是不够的？](./docs/252589.md)
* [14 | 面向对象之封装：怎样的封装才算是高内聚？](./docs/252598.md)
* [15 | 面向对象之继承：继承是代码复用的合理方式吗？](./docs/252605.md)
* [16 | 面向对象之多态：为什么“稀疏平常”的多态，是软件设计的大杀器？](./docs/252612.md)
* [17 | 函数式编程：不用函数式编程语言，怎么写函数式的程序？](./docs/256862.md)
* [18 | 函数式编程之组合性：函数式编程为什么如此吸引人？](./docs/257396.md)
* [19 | 函数式编程之不变性：怎样保证我的代码不会被别人破坏？](./docs/258214.md)
* [加餐 | 函数式编程拾遗](./docs/258954.md)
* [20 | 单一职责原则：你的模块到底为谁负责？](./docs/258222.md)
* [21 | 开放封闭原则：不改代码怎么写新功能？](./docs/261238.md)
* [22 | Liskov替换原则：用了继承，子类就设计对了吗？](./docs/261362.md)
* [23 | 接口隔离原则：接口里的方法，你都用得到吗？](./docs/263444.md)
* [24 | 依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？](./docs/264079.md)
* [25 | 设计模式：每一种都是一个特定问题的解决方案](./docs/265121.md)
* [26 | 简单设计：难道一开始就要把设计做复杂吗？](./docs/265128.md)
* [27 | 领域驱动设计：如何从零开始设计一个软件？](./docs/266819.md)
* [28 | 战略设计：如何划分系统的模块？](./docs/267837.md)
* [29 | 战术设计：如何像写故事一样找出模型？](./docs/267843.md)
* [30 | 程序库的设计：Moco是如何解决集成问题的？](./docs/267856.md)
* [31 | 应用的设计：如何设计一个数据采集平台？](./docs/269714.md)
* [32 | 应用的改进：如何改进我们的软件设计？](./docs/271178.md)
* [结束语｜那些没讲的事儿](./docs/271180.md)
* [结课测试｜这些软件设计的知识你都掌握了吗？](./docs/289693.md)
* [第三季回归 | 我们一起来写好代码！](./docs/326185.md)
* [第四季回归 | 通向高质量代码之路](./docs/404271.md)
